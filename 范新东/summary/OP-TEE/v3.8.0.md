<font size="5">目录</font>
- [文件结构](#文件结构)
- [TA编译过程](#ta编译过程)
  - [编译TA所需要的文件](#编译ta所需要的文件)
  - [make file编写基础](#make-file编写基础)
    - [ta\_dev\_kit.mk](#ta_dev_kitmk)
    - [Makefile编写](#makefile编写)
    - [sub.mk编写](#submk编写)
  - [TA入口实现](#ta入口实现)
  - [TA 属性](#ta-属性)
    - [例子](#例子)
  - [TA的签名](#ta的签名)

# 文件结构
| 根目录文件夹 | 简介 |
| -- | -- |
| bin | 存放一些系统调用程序，例如`mkdir` |
| etc | 系统配置文件目录 |
| mnt | 作为挂载点使用 |
| root | 空，超级用户的文件夹 |
| sys | 存放系统配置文件 |
| var | 存放日志缓存 |
| data | 存放数据 |
| opt | 存放第三方应用软件包 |
| run | 存放了一些进程的pid文件 | 
| tmp | 存放临时文件，所有用户对此都有读写权限 |
| dev | 存放硬件设备信息的目录 |
| lib | 存放根文件系统目录下程序和核心模块的共享库 |
| media | 挂载多媒体设备 |
| proc | 系统内存的映射，可以直接访问这个目录来获取系统信息 |
| sbin | 存放系统管理员使用的系统管理程序 |
| usr | 用户目录 |
# TA编译过程
要想在OPTEE中运行受信任的应用(Trusted Application, TA)，就必须符合OPTEE应用编译要求。以下介绍TA的编译过程。
## 编译TA所需要的文件
TA编译以及运行过程中所需要的资源依赖于编译OPTEE-OS过程中生成的TA-devkit(TA开发工具包)。而TA-devkit要求每一个TA提供：

+ Makefile：一个make文件，用于配置编译时的变量，例如库文件调用等，并包括TA-devkit make文件。
+ sub.mk：一个make文件，在其中需要列出要编译的源文件（包括本地源文件、要解析的子目录、源文件特定的编译指令）。
+ user_ta_header_defines.h：一个ANSI-C头文件，用于定义大多数TA的属性。并且在其中需要提供至少一对TA入口的实现，作为extern函数，TA-devkit提供的接口有`TA_CreateEntryPoint()`,`TA_DestoryEntryPoint()`,`TA_OpenSessionEntryPoint()`,`TA_CloseSessionEntry Point()`,`TA_InvokeCommandEntryPoint()`

完整的结构如下：

>
  ```python  
  + hello_world/                   # 工程目录
    + .../                         # 其他文件夹
    + ta/                          # TA
      + Makefile                   # 必需
      + Android.mk                 # 安卓应用可以通过调用此文件启动服务
      + sub.mk                     # 必需
      + include/                   # 存放库文件
        + hello_world_ta.h         # 所需的库文件
      + hello_world_ta.c           # TA源文件
      + user_ta_header_defines.h   # 必需
  ```
## make file编写基础
### ta_dev_kit.mk
它是用来指示TA-devkit进行资源调用的文件。它的位置在
`opteeProject/optee_os/ta/mk/ta_dev_kit.mk`。这个make文件支持编译TA或者清理编译的对象。因此可以被TA中的Makefile调用。

调用该make文件需要配置几个变量：

+ TA_DEV_KIT_DIR：TA-devkit的基本目录，用于TA-devkit定位自带工具。
+ BINARY 和 LIBNAME：显然这是两个名字，并且这两个名字各有用处。
  + 当一个TA被编译之后，则TA-devkit将其编译并签名的二进制文件命名为`${BINARY}.ta`，在原生OPTEE中，BINARY通常被用作TA的UUID，被请求服务者用来标识TA。
  + 当我们正在编译静态库时，则需要用LIBNAME来命名，例如`lib${LIBNAME}.a`
+ CROSS_COMPILE和CROSS_COMPILE32：交叉编译器。`CROSS_COMPILE32`是可选的，它允许载AArch64位机器上编译AArch32 TA程序。在AArch32位系统上默认是`CROSS_COMPILE`。

除了上述必需配置的变量之外，还有很多可选的配置变量，详情看`opteeProject/optee_os/ta/mk/ta_dev_kit.mk`

### Makefile编写
前文说过，Makefile可以引用`ta_dev_kit.mk`，因此在为一个TA编写Makefile时，典型的写法如下：
```python
# TA的UUID
BINARY=1234abcd-1234-abcd-1234-0123456789ab

# 标记出ta_dev_kit.mk的位置
include $(TA_DEV_KIT_DIR)/mk/ta_dev_kit.mk
```
### sub.mk编写
sub.mk需要列出要编译的源文件和其他指定编译指令的入口点。示例如下：

```python
# Adds /hello_world_ta.c from current directory to the list of the source
# 需要编译的文件位置。
srcs-y += hello_world_ta.c

# 标记出include的路径。
global-incdirs-y += include/

# 在文件hello_world_ta.c中添加指令-Wno-strict-prototypes（该指令用于显示第三方警告）
cflags-hello_world_ta.c-y += -Wno-strict-prototypes

# 在文件hello_world_ta.c中删除指令-Wno-strict-prototypes
cflags-remove-hello_world_ta.c-y += -Wno-strict-prototypes

# 添加静态库文件 foo 到链接器指令 -lfoo 的列表中。
libnames += foo

# 将目录路径添加到库路径列表中
libdirs += path/to/libfoo/install/directory

# 将静态二进制库文件添加到TA编译依赖中。
libdeps += path/to/greatlib/libgreatlib.a
```

## TA入口实现
在实现一个TA时，该TA需要提供至少一对强制性的入口点。

```C++
TEE_Result TA_CreateEntryPoint(void)
{
    /* 进行一些初始化工作 ... */
    ...

    /* 返回初始化状态 */
    return TEE_SUCCESS;
}

void TA_DestroyEntryPoint(void)
{
    /* 在TA退出之前释放资源 */
    ...
}

TEE_Result TA_OpenSessionEntryPoint(uint32_t ptype,
                                    TEE_Param param[4],
                                    void **session_id_ptr)
{
    /* 验证客户端的身份，通过后分配或初始化一些会话资源 */
    ...

    /* 返回工作状态 */
    return TEE_SUCCESS;
}

void TA_CloseSessionEntryPoint(void *sess_ptr)
{
    /* 验证客户端身份，通过后释放会话资源 */
    ...
}

TEE_Result TA_InvokeCommandEntryPoint(void *session_id,
                                      uint32_t command_id,
                                      uint32_t parameters_type,
                                      TEE_Param parameters[4])
{
    /* 解码目标服务的命令和要执行的程序 */
    ...

    /* 返回工作状态 */
    return TEE_SUCCESS;
}
```

## TA 属性
TA的属性应该定义在文件`user_ta_header_defines.h`中。其中应该包含：

+ TA_UUID:包含了TA的UUID值
+ TA_FLAGS:包含了TA的一些属性
+ TA_STACK_SIZE:为TA堆栈保留的RAM大小
+ TA_DATA_SIZE:为TA堆保留的RAM大小（`TEE_Malloc()`池）
### 例子
```C++
#ifndef USER_TA_HEADER_DEFINES_H
#define USER_TA_HEADER_DEFINES_H

#define TA_UUID
    { 0x8aaaf200, 0x2450, 0x11e4, \
        { 0xab, 0xe2, 0x00, 0x02, 0xa5, 0xd5, 0xc5, 0x1b} }

#define TA_FLAGS                    (TA_FLAG_EXEC_DDR | \
                        TA_FLAG_SINGLE_INSTANCE | \
                        TA_FLAG_MULTI_SESSION)
#define TA_STACK_SIZE                       (2 * 1024)
#define TA_DATA_SIZE                        (32 * 1024)

#define TA_CURRENT_TA_EXT_PROPERTIES \
    { "gp.ta.description", USER_TA_PROP_TYPE_STRING, "Foo TA for some purpose." }, \
    { "gp.ta.version", USER_TA_PROP_TYPE_U32, &(const uint32_t){ 0x0100 } }

#endif /* USER_TA_HEADER_DEFINES_H */
```
## TA的签名
所有来自REE文件系统的客户端都需要签名。在请求TA服务时由OPTEE-OS验证签名合法性。

用于签名的密钥在OPTEE-OS源代码的`keys`文件夹中。需要注意的是，不能在生产环境中使用这个密钥的私钥签名optee_os二进制文件，应该用公钥进行签名，并且将私钥离线保存。在进行离线脱机签名时，就需要用私钥进行签名了。[离线签名详情](https://optee.readthedocs.io/en/latest/building/trusted_applications.html#offline-signing-of-tas)

签名过程：TA调用`sign_encrypt.py`脚本进行签名，具体方式是调用optee_os中的`ta/mk/ta_dev_kit.mk`脚本。该py脚本默认对编译后的TA二进制文件进行签名，并且将签名附加在二进制文件后面，从而形成一个完整的TA。

目前OPTEE-OS仅支持一个单独的密钥来对TA进行签名。